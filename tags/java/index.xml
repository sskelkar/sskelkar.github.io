<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on betweencurlybraces</title>
    <link>https://sskelkar.github.io/tags/java/</link>
    <description>Recent content in Java on betweencurlybraces</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 14 Oct 2017 00:00:00 +0530</lastBuildDate>
    
	<atom:link href="https://sskelkar.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Using thread dumps to analyse deadlocks</title>
      <link>https://sskelkar.github.io/2017-10-14-using-thread-dumps-to-analyze-deadlocks/</link>
      <pubDate>Sat, 14 Oct 2017 00:00:00 +0530</pubDate>
      
      <guid>https://sskelkar.github.io/2017-10-14-using-thread-dumps-to-analyze-deadlocks/</guid>
      <description>In a multi-threaded Java application, a deadlock occurs when two threads wait forever attempting to acquire locks that are held by each other. Here’s a simple example to simulate a deadlock: public class Deadlock { private Object lock1; private Object lock2; public Deadlock(Object lock1, Object lock2) { this.lock1 = lock1; this.lock2 = lock2; } public void methodA() { System.out.println(&amp;#34;trying to acquire lock1 from - &amp;#34; + Thread.currentThread().getName()); synchronized (lock1) { someLongRunningTask(); methodB(); } } public void methodB() { System.</description>
    </item>
    
    <item>
      <title>Hystrix – a simple use case</title>
      <link>https://sskelkar.github.io/2016-12-05-hystrix-a-simple-use-case/</link>
      <pubDate>Mon, 05 Dec 2016 00:00:00 +0530</pubDate>
      
      <guid>https://sskelkar.github.io/2016-12-05-hystrix-a-simple-use-case/</guid>
      <description>Hystrix is a fault tolerance library that is very useful for managing failures in a distributed environment like microservices. Suppose we have a service A dependent on service B, which is in turn dependent on service C.
A -&amp;gt; B -&amp;gt; C  Let&amp;rsquo;s say a call is made from A to B. To serve this request, B needs to call C but there’s a communication failure between them. If the call from B to C is wrapped in Hystrix mechanism, we prevent the failure being propagated to A.</description>
    </item>
    
    <item>
      <title>Parallelizing time intensive operations with RxJava Observables</title>
      <link>https://sskelkar.github.io/2016-09-01-rxjava-observables/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0530</pubDate>
      
      <guid>https://sskelkar.github.io/2016-09-01-rxjava-observables/</guid>
      <description>Recently I delved into the RxJava library. In this post I will demonstrate how RxJava Observables can be used to execute two long running tasks in parallel, so as to reduce their overall execution time.
While we can create threads for this purpose, an additional benefit of using Observables is that it provides a convenient way of collecting the results of the parallel tasks. With threads, this can get pretty complicated.</description>
    </item>
    
    <item>
      <title>Memory profiling – simple examples</title>
      <link>https://sskelkar.github.io/2016-02-04-memory-profiling-simple-examples/</link>
      <pubDate>Thu, 04 Feb 2016 00:00:00 +0530</pubDate>
      
      <guid>https://sskelkar.github.io/2016-02-04-memory-profiling-simple-examples/</guid>
      <description>Recently I have been trying to learn different memory profiling tools to monitor Java applications. I have looked into the command line tools that are shipped as part of JDK like jstat, jps, jvisualvm etc. Licensed tools like Yourkit provide wholesome information about a running JVM including memory usage, CPU time, thread count etc. Running a java application with -verbose:gc option prints memory usage of each generation after every garbage collection event.</description>
    </item>
    
  </channel>
</rss>