

<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

 


      <title>Understanding a Postgres query plan - </title>

  <meta name="description" content="A query plan is a sequence of steps used by a database to access data. Being able to read a query plan is key to understanding the performance of an SQL query. While tuning a query we need to know how the rows are being fetched from the tables? Are the indexes being used? What is the cost of joining to tables? A query plan provides with an answer for all of these questions."><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Sojjwal Kelkar",
    
    "url": "https:\/\/sskelkar.github.io\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/sskelkar.github.io\/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/sskelkar.github.io\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/sskelkar.github.io\/post\/postgres-explain-analyze\/",
          "name": "Understanding a postgres query plan"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : ""
  },
  "headline": "Understanding a Postgres query plan",
  "description" : "A query plan is a sequence of steps used by a database to access data. Being able to read a query plan is key to understanding the performance of an SQL query. While tuning a query we need to know how the rows are being fetched from the tables? Are the indexes being used? What is the cost of joining to tables? A query plan provides with an answer for all of these questions.\n",
  "inLanguage" : "en",
  "wordCount":  2174 ,
  "datePublished" : "2020-04-13T00:00:00\u002b05:30",
  "dateModified" : "2020-04-13T00:00:00\u002b05:30",
  "image" : "https:\/\/sskelkar.github.io\/",
  "keywords" : [ "Database" ],
  "mainEntityOfPage" : "https:\/\/sskelkar.github.io\/post\/postgres-explain-analyze\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/sskelkar.github.io\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/sskelkar.github.io\/",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>


<meta property="og:title" content="Understanding a Postgres query plan" />
<meta property="og:description" content="A query plan is a sequence of steps used by a database to access data. Being able to read a query plan is key to understanding the performance of an SQL query. While tuning a query we need to know how the rows are being fetched from the tables? Are the indexes being used? What is the cost of joining to tables? A query plan provides with an answer for all of these questions.">
<meta property="og:url" content="https://sskelkar.github.io/post/postgres-explain-analyze/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Sojjwal Kelkar" />

  <meta name="twitter:title" content="Understanding a Postgres query plan" />
  <meta name="twitter:description" content="A query plan is a sequence of steps used by a database to access data. Being able to read a query plan is key to understanding the performance of an SQL query. While tuning a query we need to know how â€¦">
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="generator" content="Hugo 0.148.2">
  <link rel="alternate" href="https://sskelkar.github.io/index.xml" type="application/rss+xml" title="Sojjwal Kelkar"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.6.0/css/all.css" integrity="sha384-h/hnnw1Bi4nbpD6kE7nYfCXzovi622sY5WBxww8ARKwpdLj5kUWjRuyiXaD1U2JT" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css" integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous"><link rel="stylesheet" href="https://sskelkar.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://sskelkar.github.io/css/highlight.min.css" /><link rel="stylesheet" href="https://sskelkar.github.io/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">

  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://sskelkar.github.io/">Sojjwal Kelkar</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="Tech Blog" href="/">Tech Blog</a>
            </li>
          
        
          
            <li>
              <a title="Cartoons" href="/cartoons">Cartoons</a>
            </li>
          
        
          
            <li>
              <a title="About" href="/about">About</a>
            </li>
          
        
          
            <li>
              <a title="Tags" href="/tags">Tags</a>
            </li>
          
        

        

        
      </ul>
    </div>

    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>












<div id="header-big-imgs" data-num-img=1
     
     
     data-img-src-1="/img/library.jpg"
     
     data-img-desc-1="Path"
     ></div>


<header class="header-section has-img">
  
  <div class="intro-header big-img">
    
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          <div class="post-heading">
            <h1>Understanding a Postgres query plan</h1>
            
            
            <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Posted on Apr 13, 2020
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;11&nbsp;minutes
  
  
  
  
</span>


            
          </div>
        </div>
      </div>
    </div>
    <span class="img-desc" style="display: inline;"></span>
  </div>
  
  <div class="intro-header no-img">
    
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          <div class="post-heading">
            <h1>Understanding a Postgres query plan</h1>
            <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Posted on Apr 13, 2020
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;11&nbsp;minutes
  
  
  
  
</span>


          </div>
        </div>
      </div>
    </div>
    
  </div>
</header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <p>A query plan is a sequence of steps used by a database to access data. Being able to read a query plan is key to understanding the performance of an SQL query. While tuning a query we need to know how the rows are being fetched from the tables? Are the indexes being used? What is the cost of joining to tables? A query plan provides with an answer for all of these questions.</p>
<p>In postgres we get the query plan by prepending a query with <code>EXPLAIN</code>. Example:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">from</span> orders <span style="color:#66d9ef">where</span> created_at <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;2020-01-01&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                                    QUERY PLAN
</span></span><span style="display:flex;"><span><span style="color:#75715e">-----------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">Aggregate</span>  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">6105004</span>.<span style="color:#ae81ff">83</span>..<span style="color:#ae81ff">6105004</span>.<span style="color:#ae81ff">84</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-&gt;</span>  Seq Scan <span style="color:#66d9ef">on</span> orders  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>..<span style="color:#ae81ff">6092726</span>.<span style="color:#ae81ff">20</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">4911451</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>         Filter: (created_at <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;2020-01-01 00:00:00&#39;</span>::<span style="color:#66d9ef">timestamp</span> <span style="color:#66d9ef">without</span> time <span style="color:#66d9ef">zone</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">3</span> <span style="color:#66d9ef">rows</span>)</span></span></code></pre></div></p>
<p>A database can employ various algorithms to fetch rows and join tables. So a query plan can be dense with jargon. Let&rsquo;s go through some of the common terms that appear in a query plan and understand why the planner favors some particular fetching mechanism over others.</p>
<p>But first, we need to understand the structure of a query plan. From the <a href="https://www.postgresql.org/docs/12/using-explain.html">official documentation</a>:</p>
<blockquote>
<p>The structure of a query plan is a tree of plan nodes. Nodes at the bottom level of the tree are scan nodes: they return raw rows from a table. There are different types of scan nodes for different table access methods: sequential scans, index scans, and bitmap index scans. [&hellip;] If the query requires joining, aggregation, sorting, or other operations on the raw rows, then there will be additional nodes above the scan nodes to perform these operations. Again, there is usually more than one possible way to do these operations, so different node types can appear here too. The output of EXPLAIN has one line for each node in the plan tree, showing the basic node type plus the cost estimates that the planner made for the execution of that plan node. [&hellip;] The very first line (the summary line for the topmost node) has the estimated total execution cost for the plan; it is this number that the planner seeks to minimize.</p></blockquote>
<p>Let&rsquo;s break this down in simple terms. A query plan is structured as a tree. Each branch of this tree is called a &lsquo;plan node&rsquo;. In the query plan, each of these nodes begin with an <code>-&gt;</code> arrow. The nodes at the lowest level correspond to how rows are fetched from a table. Each node on a higher level performs some operation on its child nodes. For example, if we have a query as following: <code>select count(*) from students where age &gt; 10 and mentor_id = 1</code>. One of the possible ways this query can be processed is to fetch a set of all students whose age is greater than 10. Fetch another set of students whose mentor_id is 1. Then an AND operation is performed on both sets to get the final result. In this case, the query plan will have two bottom level nodes and with a parent node for the AND operation. There can be higher level nodes for any type of operations, like SORT, LIMIT, JOIN etc. that can be performed on raw rows.</p>
<p>Now let&rsquo;s go through each aspect of a query plan in more detail.</p>
<h2 id="fetching-raw-rows">Fetching raw rows</h2>
<p>A database can fetch rows from a table in different ways. This depends on factors such as whether appropriate indexes exist, the volume of rows to be fetched, the size of the table in question etc.</p>
<h4 id="sequential-scan">Sequential scan</h4>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">from</span> users <span style="color:#66d9ef">where</span> created_at <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;2020-01-01&#39;</span>;
</span></span><span style="display:flex;"><span>                                    QUERY PLAN
</span></span><span style="display:flex;"><span><span style="color:#75715e">-----------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">Aggregate</span>  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">3363</span>.<span style="color:#ae81ff">19</span>..<span style="color:#ae81ff">3363</span>.<span style="color:#ae81ff">20</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-&gt;</span>  Seq Scan <span style="color:#66d9ef">on</span> users  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>..<span style="color:#ae81ff">3350</span>.<span style="color:#ae81ff">90</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">4916</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>         Filter: (created_at <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;2020-01-01 00:00:00&#39;</span>::<span style="color:#66d9ef">timestamp</span> <span style="color:#66d9ef">without</span> time <span style="color:#66d9ef">zone</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">3</span> <span style="color:#66d9ef">rows</span>)</span></span></code></pre></div>
In a sequential (or full) table scan, all table rows are loaded into the memory. If the query has any filtering criteria, they will be applied in-memory on the appropriate columns. The rows that satisfy the filtering condition are transmitted further. This method is used when indexes are not present on columns present in the query predicate (where clause). In the above example, all user rows are fetched and the rows that fail on the created_at condition are discarded.</p>
<p>Even though a sequential scan may seem like a slow way of fetching data, a query planner may employ this approach even when an index is present on the filtering column. This may happen if:</p>
<ul>
<li>A table has very few rows. An index scan requires random seeks. If the whole table can fit within a few pages, it is just cheaper to load all those pages into memory, thus avoiding the overhead of random seeks.</li>
<li>A query would return a large percentage of table rows. If suppose you&rsquo;ve a query that would return 90% of all rows in a large table. In such a case, each page contains several rows that satisfy the query predicate. Again, fetching the whole page at once trumps over performing random seek that would access the same page several times.</li>
</ul>
<p>Databases maintain query statistics to determine when to use sequential scan over index scan.</p>
<h4 id="index-scan">Index scan</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">from</span> users <span style="color:#66d9ef">where</span> created_at <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;2020-01-01&#39;</span>;
</span></span><span style="display:flex;"><span>                                    QUERY PLAN
</span></span><span style="display:flex;"><span><span style="color:#75715e">-----------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">Aggregate</span>  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">319490</span>.<span style="color:#ae81ff">21</span>..<span style="color:#ae81ff">319490</span>.<span style="color:#ae81ff">22</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-&gt;</span>  <span style="color:#66d9ef">Index</span> <span style="color:#66d9ef">Only</span> Scan <span style="color:#66d9ef">using</span> index_users_created_at <span style="color:#66d9ef">on</span> users  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">56</span>..<span style="color:#ae81ff">317433</span>.<span style="color:#ae81ff">32</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">822758</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">Index</span> Cond: (created_at <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;2020-04-01 00:00:00&#39;</span>::<span style="color:#66d9ef">timestamp</span> <span style="color:#66d9ef">without</span> time <span style="color:#66d9ef">zone</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">3</span> <span style="color:#66d9ef">rows</span>)</span></span></code></pre></div>
<p>For an index scan to work an index must be present on the column used in the query predicate. The database uses that index to get the reference of all the tuples (rows) that satisfy the query predicate. Then the corresponding data page is accessed in the heap to fetch the rest of the required data from each tuple.</p>
<p>Suppose that a query has multiple predicates and all the columns in those predicates have indexes on them. The planner would typically not perform index scans for all the predicates. It would use index scan only on one of those columns and perform in-memory filtering for the remaining predicates.</p>
<p>An index scan is used for queries that have an ORDER BY condition that matches the index order. This saves an extra sorting step.</p>
<h4 id="bitmap-scan">Bitmap scan</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> users <span style="color:#66d9ef">WHERE</span> created_at <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;2020-04-01&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                                  QUERY PLAN
</span></span><span style="display:flex;"><span><span style="color:#75715e">------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Bitmap Heap Scan <span style="color:#66d9ef">on</span> users  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>.<span style="color:#ae81ff">00</span>..<span style="color:#ae81ff">20</span>.<span style="color:#ae81ff">20</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">50</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">Recheck</span> Cond: (created_at <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;2020-04-01&#39;</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-&gt;</span>  Bitmap <span style="color:#66d9ef">Index</span> Scan <span style="color:#66d9ef">on</span> users_created_at  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>..<span style="color:#ae81ff">09</span>.<span style="color:#ae81ff">00</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">50</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">Index</span> Cond: (created_at <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;2020-04-01&#39;</span>)</span></span></code></pre></div>
<p>A plain index scan fetches one tuple-pointer at a time from the index and immediately visits that tuple in the table. This may mean a single page is visited multiple times if several tuples are located in it. A more optimal use of I/O operations would be to visit a page only once and fetch all desired tuples from it. A bitmap scan does just that.</p>
<p>A bitmap index scan fetches all the tuple-pointers from the index at once and sorts them using a bitmap data structure. A bitmap heap scan visits each heap page only only once to fetch all desired tuples from it.</p>
<p>This method of row scanning has an overhead of maintaining the in-memory bitmap. If the bitmap gets too large, then we maintain only the references of the heap pages that contain matching tuples instead of keeping track of individual tuples within those pages. The whole page is loaded and the tuples are filtered on Recheck Condition to get the desired data.</p>
<h2 id="joining-tables">Joining tables</h2>
<h4 id="nested-loop-join">Nested loop join</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> p.name, t.name <span style="color:#66d9ef">from</span> players p <span style="color:#66d9ef">join</span> teams t <span style="color:#66d9ef">on</span> (t.id <span style="color:#f92672">=</span> p.team_id);
</span></span><span style="display:flex;"><span>                                   QUERY PLAN
</span></span><span style="display:flex;"><span><span style="color:#75715e">------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Nested Loop  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">56</span>..<span style="color:#ae81ff">2761623</span>.<span style="color:#ae81ff">95</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">36867792</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">14</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-&gt;</span>  Seq Scan <span style="color:#66d9ef">on</span> teams t  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>..<span style="color:#ae81ff">5528</span>.<span style="color:#ae81ff">03</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">44303</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">14</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-&gt;</span>  Materialize  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">29</span>..<span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">51</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">10</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">244</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">-&gt;</span>  <span style="color:#66d9ef">Index</span> <span style="color:#66d9ef">Only</span> Scan <span style="color:#66d9ef">using</span> index_players_on_team_id <span style="color:#66d9ef">on</span> players p  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">56</span>..<span style="color:#ae81ff">47</span>.<span style="color:#ae81ff">13</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1508</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">Index</span> Cond: (team_id <span style="color:#f92672">=</span> t.id)</span></span></code></pre></div>
<p>This method of joining two tables is preferred when one side of the join has few rows. In the above query plan all the tables are fetched via sequential scan. Then for each team id, an index scan is performed on the players table to fetch the corresponding rows.</p>
<p>In a nested loop join is performed on two nodes. A node can be a table or an intermediary step in a query plan. The second node of the join is looped over for each row in the first node. This method works better when the second node (the one that is being looped over) can be index scanned. The join column value from each row of the first node (team id in the above example) serves as the key for the index scan of the second node.</p>
<p>In the above query plan, there&rsquo;s a &lsquo;Materialize&rsquo; node above the index scan on players table. Because in a nested loop join the second relation is accessed several times, the Materialize node saves its data in memory after the first pass. The same in-memory data is used in each subsequent pass.</p>
<p>Nested loop join is the only method of joining tables if the join condition does not use the equality operator.</p>
<h4 id="hash-join">Hash join</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> p.name, t.name <span style="color:#66d9ef">from</span> players p <span style="color:#66d9ef">join</span> teams t <span style="color:#66d9ef">on</span> (t.id <span style="color:#f92672">=</span> p.team_id);
</span></span><span style="display:flex;"><span>                                   QUERY PLAN
</span></span><span style="display:flex;"><span><span style="color:#75715e">------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Hash <span style="color:#66d9ef">Join</span>  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">6082</span>.<span style="color:#ae81ff">38</span>..<span style="color:#ae81ff">1557549</span>.<span style="color:#ae81ff">17</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">36867792</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">14</span>)
</span></span><span style="display:flex;"><span>   Hash Cond: (p.team_id <span style="color:#f92672">=</span> t.id)
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-&gt;</span>  <span style="color:#66d9ef">Index</span> <span style="color:#66d9ef">Only</span> Scan <span style="color:#66d9ef">using</span> index_players_on_team_id <span style="color:#66d9ef">on</span> players p  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">56</span>..<span style="color:#ae81ff">1454680</span>.<span style="color:#ae81ff">32</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">36867792</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-&gt;</span>  Hash  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">5528</span>.<span style="color:#ae81ff">03</span>..<span style="color:#ae81ff">5528</span>.<span style="color:#ae81ff">03</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">44303</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">14</span>)
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">-&gt;</span>  Seq Scan <span style="color:#66d9ef">on</span> teams t  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>..<span style="color:#ae81ff">5528</span>.<span style="color:#ae81ff">03</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">44303</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">14</span>)</span></span></code></pre></div>
<p>In a hash join, the relation on the right side of the join is scanned and loaded into an in-memory hash table using its join attribute as the hash key. Then the left relation is scanned and the join attribute is used to look up matching row of the second relation in the hash table.</p>
<p>This join method can be used when the join condition uses the equality operator, both sides of the join are large and the hash can fit in the memory.</p>
<h4 id="merge-join">Merge join</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> p.name, t.name <span style="color:#66d9ef">from</span> players p <span style="color:#66d9ef">join</span> teams t <span style="color:#66d9ef">on</span> (t.id <span style="color:#f92672">=</span> p.team_id);
</span></span><span style="display:flex;"><span>                                   QUERY PLAN
</span></span><span style="display:flex;"><span><span style="color:#75715e">------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Merge <span style="color:#66d9ef">Join</span>  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">198</span>.<span style="color:#ae81ff">11</span>..<span style="color:#ae81ff">268</span>.<span style="color:#ae81ff">19</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">10</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">488</span>)
</span></span><span style="display:flex;"><span>   Merge Cond: (p.team_id <span style="color:#f92672">=</span> t.id)
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-&gt;</span>  <span style="color:#66d9ef">Index</span> Scan <span style="color:#66d9ef">using</span> index_players_on_team_id <span style="color:#66d9ef">on</span> players p  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">29</span>..<span style="color:#ae81ff">656</span>.<span style="color:#ae81ff">28</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">101</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">244</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-&gt;</span>  Sort  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">197</span>.<span style="color:#ae81ff">83</span>..<span style="color:#ae81ff">200</span>.<span style="color:#ae81ff">33</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">244</span>)
</span></span><span style="display:flex;"><span>         Sort <span style="color:#66d9ef">Key</span>: t.id
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">-&gt;</span>  Seq Scan <span style="color:#66d9ef">on</span> teams t  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>..<span style="color:#ae81ff">148</span>.<span style="color:#ae81ff">00</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">244</span>)</span></span></code></pre></div>
<p>In this join method, both relations are first sorted on the join attribute. Then the two relations are scanned in parallel to find the matching rows. This method can be used when the join condition uses the equality operator, both sides of the join are large but can be efficiently sorted on the join attribute.</p>
<p>In the above example, players is sorted using the index on team_id column. The team table could also be sorted on its primary key. But in this instance, the query planner preferred a sequential scan and sort. A sequential scan and sort is preferable than an index sort when the table is large and cost of the nonsequential disk access required by the index scan is higher than a simple full scan and sorting.</p>
<h2 id="cost-estimation">Cost estimation</h2>
<p>Each node is accompanied by a cost estimation that takes the form <code>(cost=10.00..20.00 rows=1 width=8)</code>. The costs are measured in an arbitrary unit determined by the planner&rsquo;s cost parameters. One of the ways the cost can be measured is in the unit of disk page fetches. The cost of an upper level node includes the cost of all its child nodes. Brief description of each field in the cost estimation:</p>
<ul>
<li>cost: This is a range of the estimated start-up cost and the estimated total cost. The start-up cost is the time spent before the tranmission of output rows begin. This may include the time required for sorting. The total cost is the time estimation for transmitting all eligible rows assuming the query would run to completion. Meaning, there may be a LIMIT clause in an outer query that would limit the number of transmitted rows. But the estimates don&rsquo;t consider these scenarios.</li>
<li>rows: Estimated number of rows emitted by a plan node</li>
<li>width: Estimated average width of rows emitted by a plan node in bytes.</li>
</ul>
<h2 id="explain-analyze">EXPLAIN ANALYZE</h2>
<p><code>EXPLAIN</code> by itself just provides the query plan with cost estimation. If we execute a query with <code>EXPLAIN ANALYZE</code>, the query is actually executed. In each plan node, the true row count and the true run time is displayed along with the estimates. So that we can check the accuracy of the planner&rsquo;s estimation.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">analyze</span> <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">from</span> users <span style="color:#66d9ef">where</span> created_at <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;2020-04-01&#39;</span>;
</span></span><span style="display:flex;"><span>                                 QUERY PLAN
</span></span><span style="display:flex;"><span><span style="color:#75715e">------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">Aggregate</span>  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">3356</span>.<span style="color:#ae81ff">22</span>..<span style="color:#ae81ff">3356</span>.<span style="color:#ae81ff">23</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>) (actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">7</span>.<span style="color:#ae81ff">357</span>..<span style="color:#ae81ff">7</span>.<span style="color:#ae81ff">358</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">-&gt;</span>  Seq Scan <span style="color:#66d9ef">on</span> users  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>..<span style="color:#ae81ff">3350</span>.<span style="color:#ae81ff">90</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">2126</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) (actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">007</span>..<span style="color:#ae81ff">7</span>.<span style="color:#ae81ff">241</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">2132</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        Filter: (created_at <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;2020-04-01 00:00:00&#39;</span>::<span style="color:#66d9ef">timestamp</span> <span style="color:#66d9ef">without</span> time <span style="color:#66d9ef">zone</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">Rows</span> Removed <span style="color:#66d9ef">by</span> Filter: <span style="color:#ae81ff">37060</span>
</span></span><span style="display:flex;"><span>Planning Time: <span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">159</span> ms
</span></span><span style="display:flex;"><span>Execution Time: <span style="color:#ae81ff">7</span>.<span style="color:#ae81ff">379</span> ms
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">6</span> <span style="color:#66d9ef">rows</span>)</span></span></code></pre></div></p>
<p>Depending on the query plan, EXPLAIN ANALYZE provides much richer information than just actual costs. This includes:</p>
<ul>
<li>The number of actual loops performed in a nested loop join</li>
<li>If sorting was involved, then the algorithm and the amount of memory used for sorting</li>
<li>If hash joins were involved, the number of hash buckets and the peak memory used for hash tables</li>
<li>Rows rejected by a filter condition or an index recheck</li>
</ul>


        
          <div class="blog-tags">
            
              
              <a href="https://sskelkar.github.io/tags/database/">Database</a>&nbsp;
            
          </div>
        

        

        
          
            
          

          
                  <h4 class="see-also">See also</h4>
                  <ul>
                
                
                    <li><a href="/post/jpa-entity-relationships/">JPA Entity Relationships</a></li>
                
              </ul>

          
        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://sskelkar.github.io/post/db-integration-tests-for-spring-app/" data-toggle="tooltip" data-placement="top" title="Database integration tests for a Spring application">&larr; Previous Post</a>
            </li>
          
          
            <li class="next">
              <a href="https://sskelkar.github.io/post/squashing-ruby-on-rails-database-migrations/" data-toggle="tooltip" data-placement="top" title="Squashing ruby on rails database migrations">Next Post &rarr;</a>
            </li>
          
        </ul>
      


      
      
      
      
      
        
      

    </div>
  </div>
</div>

      <footer>
  <div class="container">
    
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
          
          
        </ul>
        <p class="credits copyright text-muted">
          

          &nbsp;&bull;&nbsp;&copy;
          
            2025
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://sskelkar.github.io/">Sojjwal Kelkar</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          &bull;&nbsp;Powered by Hugo&nbsp;&bull;&nbsp;
          
        </p>
      </div>
    </div>
  </div>
</footer><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" integrity="sha384-w5y/xIeYixWvfM+A1cEbmHPURnvyqmVg5eVENruEdDjcyRLUSNej7512JQGspFUr" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js" integrity="sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd" crossorigin="anonymous"></script>

<script src="https://sskelkar.github.io/js/main.js"></script>
<script src="https://sskelkar.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://sskelkar.github.io/js/load-photoswipe.js"></script>










    
  </body>
</html>

