<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on betweencurlybraces</title>
    <link>https://sskelkar.github.io/post/</link>
    <description>Recent content in Posts on betweencurlybraces</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 08 Nov 2017 00:00:00 +0530</lastBuildDate>
    
	<atom:link href="https://sskelkar.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Representing natural numbers in lambda calculus</title>
      <link>https://sskelkar.github.io/2017-11-08-representing-natural-numbers-in-lambda-calculus/</link>
      <pubDate>Wed, 08 Nov 2017 00:00:00 +0530</pubDate>
      
      <guid>https://sskelkar.github.io/2017-11-08-representing-natural-numbers-in-lambda-calculus/</guid>
      <description>One of the joys of reading SICP is that apart from the main subject matter, we come across many tangential topics that are interesting in their own right. One such topic is mentioned in Exercise 2.6: Church numerals. Named after the mathematician Alonzo Church, Church numerals are a way of representing natural numbers in lambda calculus. But what is λ-calculus?
From a programming perspective, λ-calculus can be thought of as the smallest universal programming language.</description>
    </item>
    
    <item>
      <title>Using thread dumps to analyse deadlocks</title>
      <link>https://sskelkar.github.io/2017-10-14-using-thread-dumps-to-analyze-deadlocks/</link>
      <pubDate>Sat, 14 Oct 2017 00:00:00 +0530</pubDate>
      
      <guid>https://sskelkar.github.io/2017-10-14-using-thread-dumps-to-analyze-deadlocks/</guid>
      <description>In a multi-threaded Java application, a deadlock occurs when two threads wait forever attempting to acquire locks that are held by each other. Here’s a simple example to simulate a deadlock: public class Deadlock { private Object lock1; private Object lock2; public Deadlock(Object lock1, Object lock2) { this.lock1 = lock1; this.lock2 = lock2; } public void methodA() { System.out.println(&amp;#34;trying to acquire lock1 from - &amp;#34; + Thread.currentThread().getName()); synchronized (lock1) { someLongRunningTask(); methodB(); } } public void methodB() { System.</description>
    </item>
    
    <item>
      <title>Setting up a JavaScript project in 2017</title>
      <link>https://sskelkar.github.io/2017-01-14-setting-up-a-javascript-project-in-2017/</link>
      <pubDate>Sat, 14 Jan 2017 00:00:00 +0530</pubDate>
      
      <guid>https://sskelkar.github.io/2017-01-14-setting-up-a-javascript-project-in-2017/</guid>
      <description>Creating a front-end JavaScript project can be a daunting task due to the sheer volume of choices available while deciding the tech stack. First, you need to decide the JavaScript framework or library for your project. Do you plan to use the latest ES2015 language features in your code? If yes, then you need a transpiler because your browser probably doesn’t support them yet. Then you require a bundling tool to get your code loaded in the browser.</description>
    </item>
    
    <item>
      <title>Hystrix – a simple use case</title>
      <link>https://sskelkar.github.io/2016-12-05-hystrix-a-simple-use-case/</link>
      <pubDate>Mon, 05 Dec 2016 00:00:00 +0530</pubDate>
      
      <guid>https://sskelkar.github.io/2016-12-05-hystrix-a-simple-use-case/</guid>
      <description>Hystrix is a fault tolerance library that is very useful for managing failures in a distributed environment like microservices. Suppose we have a service A dependent on service B, which is in turn dependent on service C.
A -&amp;gt; B -&amp;gt; C  Let&amp;rsquo;s say a call is made from A to B. To serve this request, B needs to call C but there’s a communication failure between them. If the call from B to C is wrapped in Hystrix mechanism, we prevent the failure being propagated to A.</description>
    </item>
    
    <item>
      <title>Parallelizing time intensive operations with RxJava Observables</title>
      <link>https://sskelkar.github.io/2016-09-01-rxjava-observables/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0530</pubDate>
      
      <guid>https://sskelkar.github.io/2016-09-01-rxjava-observables/</guid>
      <description>Recently I delved into the RxJava library. In this post I will demonstrate how RxJava Observables can be used to execute two long running tasks in parallel, so as to reduce their overall execution time.
While we can create threads for this purpose, an additional benefit of using Observables is that it provides a convenient way of collecting the results of the parallel tasks. With threads, this can get pretty complicated.</description>
    </item>
    
    <item>
      <title>Memory profiling – simple examples</title>
      <link>https://sskelkar.github.io/2016-02-04-memory-profiling-simple-examples/</link>
      <pubDate>Thu, 04 Feb 2016 00:00:00 +0530</pubDate>
      
      <guid>https://sskelkar.github.io/2016-02-04-memory-profiling-simple-examples/</guid>
      <description>Recently I have been trying to learn different memory profiling tools to monitor Java applications. I have looked into the command line tools that are shipped as part of JDK like jstat, jps, jvisualvm etc. Licensed tools like Yourkit provide wholesome information about a running JVM including memory usage, CPU time, thread count etc. Running a java application with -verbose:gc option prints memory usage of each generation after every garbage collection event.</description>
    </item>
    
    <item>
      <title>Closures in JavaScript</title>
      <link>https://sskelkar.github.io/2015-07-20-closures-in-javascript/</link>
      <pubDate>Mon, 20 Jul 2015 00:00:00 +0530</pubDate>
      
      <guid>https://sskelkar.github.io/2015-07-20-closures-in-javascript/</guid>
      <description>A good understanding of closures is a must-have skill for any JavaScript programmer. So let&amp;rsquo;s take a look at how they work with two simple examples.
In JavaScript, functions are first class citizens. This means a function can be passed as an argument to another function, returned as the value from a function, assigned to a variable and stored in a data structure.
We can even write a function within a function, and the inner function has access to the environment within which it was created.</description>
    </item>
    
    <item>
      <title>Dependency Injection in AngularJS 1.x</title>
      <link>https://sskelkar.github.io/2015-07-19-dependency-injection-in-angularjs-1x/</link>
      <pubDate>Sun, 19 Jul 2015 00:00:00 +0530</pubDate>
      
      <guid>https://sskelkar.github.io/2015-07-19-dependency-injection-in-angularjs-1x/</guid>
      <description>AngularJS Dependency Injection works like magic! You pass a service name in your controller constructor function and angular runtime promptly provides you with a suitable object. While this makes development process easier, it might be a little disconcerting if you don’t know what’s happening behind the scene. In this article, I will take a look at how angular DI works.
In an Angular application, user can create different kinds of components like: directives, controllers, services etc.</description>
    </item>
    
  </channel>
</rss>